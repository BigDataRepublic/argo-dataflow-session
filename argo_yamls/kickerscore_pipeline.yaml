---
apiVersion: dataflow.argoproj.io/v1alpha1
kind: Pipeline
metadata:
  annotations:
    dataflow.argoproj.io/description: Amazing kickerscore attempt
    dataflow.argoproj.io/owner: argoproj-labs
  name: kickerscore-pipeline
spec:
  steps:
    # First implement something that makes sure that only valid teams pass, that means to exclude invalid and cheaters
    - filter:
        expression: |-
          ! (string(msg) contains "Invalid Teamname" || string(msg) contains "Cheaters")
      name: input
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_input
            topic: kicker_results
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_filter_teams
          name: kafka
#        - log: {}
#          name: logger
    # Then implement a mapping to only extract the winner data from the json messages
    - map:
        expression: |-
          json(object(msg)["winner"])
      name: winners
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_filtered_0
            topic: kicker_filter_teams
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_winners
          name: kafka
#        - log: {}
#          name: logger
    - map:
        expression: |-
          json(object(msg)["loser"])
      name: losers
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_filtered_1
            topic: kicker_filter_teams
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_losers
          name: kafka
#        - log: {}
#          name: logger
    # Using that information, you can use the code below that should work if you did not do anything strange above.
    # Just have some fun changing random things.
    - group:
        endOfGroup: |-
          string(msg) contains "limit"
        format: JSONStringArray
        key: |-
          object(msg)["team"]
        storage:
          name: groups
      name: group-winners
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_grouped_winners
          name: kafka
#        - log: {}
#          name: logger
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_winners
            topic: kicker_winners
          name: kafka_winners
        - kafka:
            name: kickerscore
            groupId: kicker_reader_limit
            topic: kicker_timer
          name: kicker_timer
      volumes:
        - emptyDir: {}
          name: groups
    - code:
        runtime: python3-9
        source: |
          import json

          def handler(msg, context):
              json_obj = json.loads(msg)
              # Expects something like ['{"score":10,"team":"Team A"}', '{"team": "Team A", "limit": true}']
              # Note the nested json because of the group string to json step
              print(json_obj)
              wins = len(json_obj) - 1
              print(f"Wins: {wins}")
              return json.dumps({"team": json.loads(json_obj[0])["team"], "wins": wins, "category": "All"}).encode("UTF-8")
      name: sum-winners
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_summed_winners
          name: kafka
#        - log: {}
#          name: logger
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_group
            topic: kicker_grouped_winners
    - group:
        endOfGroup: |-
          object(msg)["team"] contains "ALL"
        format: JSONStringArray
        key: |-
          object(msg)["category"]
        storage:
          name: winsgroup
      name: group-num-wins
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_grouped_num_wins
          name: kafka
#        - log: {}
#          name: logger
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_summed_winners
            topic: kicker_summed_winners
          name: kafka_summed_winners
      volumes:
        - emptyDir: {}
          name: winsgroup
    - code:
        runtime: python3-9
        source: |
          import json
          from datetime import datetime

          def handler(msg, context):
              json_obj = json.loads(msg)
              # Expects something like ['{"score":10,"team":"Team A"}', '{"team": "Team A", "limit": true}']
              # Note the nested json because of the group string to json step
              print(json_obj)
              champion = json.loads(sorted(json_obj, key=lambda p: json.loads(p)['wins'], reverse=True)[0])
              return json.dumps({"champion": champion["team"], "at": str(datetime.now()), "wins": champion["wins"]}).encode("UTF-8")
      name: champion
      sinks:
        - kafka:
            name: kickerscore
            topic: kicker_champions
          name: kafka
#        - log: {}
#          name: logger
      sources:
        - kafka:
            name: kickerscore
            groupId: kicker_reader_num_wins
            topic: kicker_grouped_num_wins
